<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>組手</title>

<style>
:root{
      --box-w: 86px;
      --box-h: 104px;
      --btn-h: 40px;
      --btn-fs: 12px;
      --name-fs: 12px;
      /* ② 試合枠の上下間隔*/
      --gap-y: 20px;
      --top-pad: 14px;
      --col-gap: 20px;
      --side-w: 26px;
      --side-gap: 8px;

      --wrapper-h: 560px;
      --match-pad: 4px;
      --player-my: 2px;
      --side-btn-h: 35px;
      --side-btn-w: 24px;

      --final-accent:#2563eb;

      /* ① 最下段matchとwrapper下端の余白 */
      --bottom-gap: 30px;
    }

    html,body{margin:0;padding:0;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;background:#fff;color:#111;}
    body{overflow-x:hidden;}
    #page{padding:8px;box-sizing:border-box;max-width:520px;margin:0 auto;}

    .titleBox{border:1px solid #111;padding:6px 8px;box-sizing:border-box;}
    #metaTitle{
      width:100%;border:none;outline:none;font-weight:900;font-size:20px;line-height:1.2;
      background:transparent;padding:0;margin:0;
    }

    #topGrid{
      display:grid;
      grid-template-columns: 0.95fr 1.05fr; /* 縦でも左右2列固定 */
      gap:12px;
      align-items:start;
      margin-top:8px;
    }
    .card{border:none;padding:0;box-sizing:border-box;}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .row + .row{margin-top:10px;}

        #courtPalette{
      display:grid;
      grid-template-columns:repeat(4,46px);
      gap:8px;
      align-items:center;
    }
    .court-input{
      width:46px;height:46px;text-align:center;font-size:16px;box-sizing:border-box;background:#fff;
      border:4px solid #ddd;border-radius:6px;
    }
    .court-input.selected{outline:4px solid var(--final-accent);outline-offset:2px;}

    input[type="number"], input[type="text"]{
      border:1px solid #777;border-radius:8px;padding:8px 5px;font-size:15px;box-sizing:border-box;
      background:#fff;
    }
    #courtCountInput{width:66px;text-align:center;}
    #metaType,#metaStyle{width:85px;text-align:center;}
    #metaCategory{width:190px;}

    button{
      font-size:15px;padding:9px 14px;border:1px solid #777;border-radius:12px;background:#e9e9e9;
    }
    button:disabled{opacity:.45;}


    #players{
      width:100%;
      min-height:260px;
      font-size:15px;
      padding:6px;
      box-sizing:border-box;
      border:1px solid #111;
      resize:vertical;
    }

    /* ===== トーナメント ===== */
    .wrapper{
      position:relative;
      width:100%;
      height:var(--wrapper-h);
      overflow:auto;
      border:1px solid #111;
      background:#fff;
      margin-top:10px;
    }
    #tournament{
      position:relative;
      display:inline-flex;
      align-items:flex-start;
      white-space:nowrap;
      padding: 14px 16px calc(12px + var(--bottom-gap)) 10px; /* ① */
      box-sizing:border-box;
    }
    #lines{position:absolute;inset:0;pointer-events:none;}

    .side-column{
      position:relative;
      width:var(--side-w);
      min-width:var(--side-w);
      margin-right:var(--side-gap);
    }
    .side-row{
      position:absolute;left:0;width:100%;
      display:flex;justify-content:flex-start;
      padding-left:1px;box-sizing:border-box;
    }
    .side-btn{
      width:var(--side-btn-w);
      height:var(--side-btn-h);
      padding:0;
      font-size:12px;
      border-radius:4px;
      border:1px solid #777;
      background:#efefef;
      pointer-events:auto;
      display:flex;align-items:center;justify-content:center;
      line-height:1;
    }
    .side-btn.state-欠{opacity:.6;}
    .side-btn.state-棄{text-decoration:line-through;opacity:.7;}
    .side-btn.state-済{background:#dff1ff;border-color:#5aa7ff;}
    .side-btn.state-未{background:#fff7db;border-color:#f0c44b;}

    .column{
      position:relative;
      width:calc(var(--box-w) + 20px);
      min-width:calc(var(--box-w) + 20px);
      overflow:visible;
      margin-right:var(--col-gap);
    }
    .match-wrapper{position:absolute;width:auto;height:var(--box-h);overflow:visible;}
    .match{
      width:var(--box-w);
      border:1px solid #111;
      padding:var(--match-pad);
      box-sizing:border-box;
      background:#fff;
      border-radius:6px;
    }

    .playerBtn{
      display:block;
      width:100%;
      height:var(--btn-h);
      margin: var(--player-my) 0;
      font-size:var(--btn-fs);
      line-height:1.05;
      padding:2px 6px;
      text-align:center;
      box-sizing:border-box;
      white-space:normal;
      word-break:break-word;
      border:1px solid #777;
      border-radius:6px;
      background:#fff;
    }
    .playerBtn .ln,.playerBtn .fn{display:block;font-size:var(--name-fs);}
    button.selected{background:#cce5ff;border:2px solid #3399ff;}
    button.winner{background:#99edf8;border:2px solid #3374ff;font-weight:900;}
    button.loser{opacity:.45;pointer-events:none;}
    button.seed{color:#999!important;opacity:.35;cursor:not-allowed;background:#f2f2f2;}
    .playerBtn.absent{opacity:.35;cursor:not-allowed;}
    .playerBtn.withdraw{opacity:.55;text-decoration:line-through;cursor:not-allowed;}

    .matchLabel{
      position:absolute;
      top:-18px;left:0;right:0;
      text-align:center;
      font-size:12px;
      color:#666;
      pointer-events:none;
    }

    #rankCard{
      margin-top:10px;
      border:1px solid #111;
      padding:8px;
      box-sizing:border-box;
      border-radius:12px;
    }
    #rankCardTitle{font-weight:900;margin-bottom:6px;}
    #rankAll{font-size:13px;font-weight:900;}
    #rankAll div.seed-rank{color:#bbb!important;opacity:.25!important;font-weight:normal!important;}

    /* ③ 保存ボタン */
    #tempSaveBtn{ }
    #finalSaveBtn{ width:100px; margin-top:10px; }
  
    select{
      border:1px solid #777;
      border-radius:8px;
      padding:8px 5px;
      font-size:15px;
      box-sizing:border-box;
      background:#fff;
    }
    #catSelect{width:190px;max-width:100%;}
    #lastSync{min-width:120px;}



/* ===== viewer 最小表示（kumite） ===== */
.viewerHeader{text-align:center; margin:8px 0 10px;}
.viewerTitle{font-size:18px; font-weight:900; line-height:1.3;}
.viewerMeta{margin-top:6px; font-size:13px; font-weight:800;}
.viewerMeta span{margin:0 6px;}
body.viewer-mode { margin:8px; }
body.viewer-mode #page{ padding:0; }
body.viewer-mode .titleBox{ display:none !important; }
body.viewer-mode #viewerHeader{ display:block !important; }
body.viewer-mode #topGrid{ display:none !important; }
body.viewer-mode .wrapper{ border:none !important; background:transparent !important; margin-top:6px !important; }
body.viewer-mode input, 
body.viewer-mode textarea, 
body.viewer-mode select{ display:none !important; }

/* 編集用ボタン類のみ非表示（トーナメント内のボタンは残す） */
body.viewer-mode #topGrid button,
body.viewer-mode #finalBtnBar,
body.viewer-mode #finalBtnBar button,
body.viewer-mode #setCourtCountBtn,
body.viewer-mode #saveServerBtn,
body.viewer-mode #loadServerBtn,
body.viewer-mode #tempSaveBtn,
body.viewer-mode #finalSaveBtn,
body.viewer-mode #downloadJsonBtn,
body.viewer-mode #uploadJsonBtn,
body.viewer-mode #clearBtn,
body.viewer-mode #resetBtn{ display:none !important; }

/* ===== viewer表示をはっきり黒にする ===== */
body.viewer-mode .playerBtn,
body.viewer-mode .player,
body.viewer-mode .name,
body.viewer-mode .match,
body.viewer-mode .matchBox,
body.viewer-mode .slot,
body.viewer-mode .winner {
  color: #000 !important;
  border-color: #000 !important;
  background: #fff !important;
  opacity: 1 !important;
}

/* viewer用：一覧へ戻るボタン */
.backIndex{
  position: fixed;
  top: 6px;
  right: 6px;
  z-index: 9999;

  font-size: 12px;
  padding: 4px 8px;
  background: rgba(0,0,0,.55);
  color: #fff;
  border-radius: 999px;
  text-decoration: none;
  line-height: 1;
}

</style>
</head>

<body>
<div id="page">
  <div class="titleBox">
    <input id="metaTitle" type="text" value="第00回 神奈川県空手道選手権大会" />
  </div>

  <!-- viewer用：indexに戻る -->
  <a href="./index.html" class="backIndex">一覧へ</a>

  <div id="viewerHeader" class="viewerHeader" style="display:none;">
    <div id="viewerTitle" class="viewerTitle"></div>
    <div class="viewerMeta">
      <span id="viewerCourt"></span>
      <span id="viewerCategory"></span>
    </div>
  </div>


  <div id="topGrid">
    <div class="card">
      <div class="row">
        <div style="font-weight:900;font-size:16px;">コート：</div>
        <div id="courtPalette"></div>
      </div>

      <div class="row">
        <input id="courtCountInput" type="number" min="1" max="8" value="1">
        <div style="font-weight:900;">コート数
        <button id="setCourtCountBtn" type="button">表示</button></div>
      </div>

      <div class="row">
        <input id="metaStyle" type="text" value="個人戦">
        <div style="font-weight:900;">/</div>
        <input id="metaType" type="text" value="組手">
      </div>

      <div class="row">
        <input id="metaCategory" type="text" value="一般男子の部">
      </div>

   
      <div class="row" id="catRow">
        <select id="catSelect"></select>
      </div>
   

      <div class="row" id="syncRow">
        <input id="whoInput" type="text" placeholder="更新者(任意)" style="width:120px;" />
        <button id="srvLoadBtn" type="button">サーバー読込</button>
        <button id="srvSaveBtn" type="button">サーバー保存</button>
      </div>

      <div class="row" id="viewerRow" style="display:none;align-items:center;gap:10px;flex-wrap:wrap;">
        <button id="refreshBtn" type="button">更新</button>
        <label style="display:flex;align-items:center;gap:6px;font-weight:900;font-size:13px;">
          <input id="autoRefreshToggle" type="checkbox" />自動更新
        </label>
        <input id="autoRefreshSec" type="number" min="10" max="600" value="90" style="width:70px;text-align:center;" />
        <div id="lastSync" style="font-size:12px;opacity:.85;"></div>
      </div>


      <div class="row">
        <button id="startBtn" type="button">開始</button>
        <button id="tempSaveBtn" type="button">一時保存</button>
        <button id="loadBtn" type="button">受信JSON読込</button>
        <input id="loadFile" type="file" accept="application/json,.json" style="display:none" />
      </div>
    </div>

    <div class="card">
      <textarea id="players" placeholder="選手登録欄
苗字と名の間は全角スペース
例）神奈川　県太郎 / 1行1名"></textarea>
    </div>
  </div>

  <div class="wrapper" id="wrapper">
    <svg id="lines"></svg>
    <div id="tournament"></div>
  </div>

  <div id="rankCard">
    <div id="rankCardTitle">順位表</div>
    <div id="rankAll">
      <div id="rank1">1位：--</div>
      <div id="rank2">2位：--</div>
      <div id="rank3">3位：--</div>
      <div id="rank4">4位：--</div>
      <div id="rank5">5位：--</div>
      <div id="rank6">6位：--</div>
      <div id="rank7">7位：--</div>
      <div id="rank8">8位：--</div>
    </div>
  </div>
  <button id="finalSaveBtn" type="button">確定保存</button>
</div>

<script>
// viewer-mode判定（最小表示）
(() => {
  const params = new URLSearchParams(location.search);
  if (params.get("mode") !== "viewer") return;

  document.body.classList.add("viewer-mode");

  // タイトル（編集側inputの値を表示）
  const titleInput = document.getElementById("metaTitle");
  const title = titleInput ? (titleInput.value || "").trim() : "";
  const titleEl = document.getElementById("viewerTitle");
  if (titleEl) titleEl.textContent = title || "第00回 神奈川県空手道選手権大会";

  // コート（URL ?court=1 など。無ければ 1）
  const court = (params.get("court") || "1").trim();
  const courtEl = document.getElementById("viewerCourt");
  if (courtEl) courtEl.textContent = `コート：[${court}]`;

  // カテゴリー（URL ?cat=...）
  const cat = (params.get("cat") || "").trim();

  const CAT_LABELS = {
    // 団体
    "team_e34_m":"小学３・４年男子の部",
    "team_e34_f":"小学３・４年女子の部",
    "team_e56_m":"小学５・６年男子の部",
    "team_e56_f":"小学５・６年女子の部",
    "team_jhs_m":"中学生男子の部",
    "team_jhs_f":"中学生女子の部",
    "team_hs_m":"高校生男子の部",
    "team_hs_f":"高校生女子の部",
    "team_adult_m":"一般男子の部",
    "team_adult_f":"一般女子の部",
    // 個人
    "ind_e3_m":"小学３年男子の部",
    "ind_e3_f":"小学３年女子の部",
    "ind_e4_m":"小学４年男子の部",
    "ind_e4_f":"小学４年女子の部",
    "ind_e5_m":"小学５年男子の部",
    "ind_e5_f":"小学５年女子の部",
    "ind_e6_m":"小学６年男子の部",
    "ind_e6_f":"小学６年女子の部",
    "ind_j1_m":"中学１年男子の部",
    "ind_j1_f":"中学１年女子の部",
    "ind_j2_m":"中学２年男子の部",
    "ind_j2_f":"中学２年女子の部",
    "ind_j3_m":"中学３年男子の部",
    "ind_j3_f":"中学３年女子の部",
    "ind_hs_m":"高校生男子の部",
    "ind_hs_f":"高校生女子の部",
    "ind_adult_m":"一般男子の部",
    "ind_adult_f":"一般女子の部"
  };

  const group = cat.startsWith("team_") ? "団体戦" : (cat.startsWith("ind_") ? "個人戦" : "カテゴリー");
  const label = CAT_LABELS[cat] || (cat ? cat : "未指定");
  const catEl = document.getElementById("viewerCategory");
  if (catEl) catEl.textContent = `カテゴリー：${group} / 組手 ${label}`;
})();


  const APP_KIND = "kumite";
let courtList = ["-"];
const courtColors = [
  { bg: "#fafafa", border: "#dddddd" },
  { bg: "#e0f0ff", border: "#9ec5ff" },
  { bg: "#e6ffe6", border: "#9ee6b0" },
  { bg: "#fff2e0", border: "#f5c79a" },
  { bg: "#f0e6ff", border: "#c9a8f7" },
  { bg: "#ffe0f0", border: "#f3a8c9" },
  { bg: "#e0fff7", border: "#9ee6d5" },
  { bg: "#f7ffe0", border: "#c9e69a" }
];
let selectedCourt = "-";

let state = {
  players: [],
  rounds: [],
  thirdMatch: { players: [], winner: null, court: null }
};

const LONG_PRESS_TIME = 600;
let pendingWin = null;

const TEMP_KEY = "karate_tournament_temp_v1";

function getCssNum(name, fallback){
  const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  if(!v) return fallback;
  const n = Number(String(v).replace("px",""));
  return Number.isFinite(n) ? n : fallback;
}
function splitName(name){
  const n = (name || "").trim();
  if(!n) return ["—",""];
  if(n === "seed") return ["seed",""];
  const parts = n.split(/　+/);
  if(parts.length >= 2) return [parts[0], parts.slice(1).join("　")];
  return [n,""];
}
function isSeed(p){ return p && p.name === "seed"; }
function isDash(p){ return p && String(p.name||"").trim() === "-"; }
function isAbsent(p){ return p && p.attendance === "欠"; }
function isWithdraw(p){ return p && p.attendance === "棄"; }
function clearSelection(){
  document.querySelectorAll(".selected").forEach(b=>b.classList.remove("selected"));
  pendingWin = null;
}

function buildCourtPalette(){
  const area = document.getElementById("courtPalette");
  area.innerHTML = "";
  courtList.forEach((nameToggle, i) => {
    const inp = document.createElement("input");
    inp.className = "court-input";
    inp.dataset.index = i;

    if(!nameToggle){ courtList[i] = "-"; nameToggle = "-"; }
    inp.value = nameToggle;

    const c = courtColors[i % courtColors.length];
    inp.style.border = "4px solid " + c.border;

    const setSelected = () => {
      selectedCourt = (inp.value.trim() || "-");
      document.querySelectorAll(".court-input").forEach(x=>x.classList.remove("selected"));
      inp.classList.add("selected");
    };
    inp.addEventListener("focus", setSelected);
    inp.addEventListener("click", setSelected);
    inp.addEventListener("input", () => {
      courtList[i] = inp.value.trim() || "-";
      selectedCourt = courtList[i];
    });

    area.appendChild(inp);
  });

  const first = area.querySelector(".court-input");
  if(first){
    first.classList.add("selected");
    selectedCourt = first.value.trim() || "-";
  }else{
    selectedCourt = "-";
  }
}
function applyCourtCount(){
  const count = Math.max(1, Math.min(8, Number(document.getElementById("courtCountInput").value || 1)));
  courtList = Array(count).fill("-");
  buildCourtPalette();
}
document.getElementById("setCourtCountBtn").addEventListener("click", applyCourtCount);

function decideBracketSize(n){
  if(n <= 2) return 2;
  if(n <= 4) return 4;
  if(n <= 8) return 8;
  if(n <= 16) return 16;
  if(n <= 32) return 32;
  if(n <= 64) return 64;
  if(n <= 128) return 128;
  return 256;
}

function makeSeed(){ return { id:null, name:"seed", attendance:"-" }; }

function buildRoundsFull(){
  state.rounds = [];
  state.thirdMatch = { players: [], winner: null, court: null };

  const n = state.players.length;
  const size = decideBracketSize(n);

  const list = state.players.slice();
  while(list.length < size) list.push(makeSeed());

  const r0 = [];
  for(let i=0;i<size;i+=2){
    r0.push({ players:[list[i], list[i+1]], winner:null, court:null });
  }
  state.rounds.push(r0);

  while(state.rounds[state.rounds.length-1].length > 1){
    const prev = state.rounds[state.rounds.length-1].length;
    const nextCount = Math.floor(prev/2);
    const rr = [];
    for(let m=0;m<nextCount;m++){
      rr.push({ players:[null,null], winner:null, court:null });
    }
    state.rounds.push(rr);
  }

  state.rounds.forEach((round, r)=>round.forEach((_, m)=>autoJudgeMatch(r,m)));
}

function calcY(r, m){
  const BOX_H = getCssNum("--box-h", 88);
  const GAP = getCssNum("--gap-y", 20);
  if(r===0) return m*(BOX_H+GAP);
  const p=m*2;
  return (calcY(r-1,p)+calcY(r-1,p+1))/2;
}

const ATT_STATES = ["-","済","未","欠","棄"];

function clearPlayerAdvances(player){
  for(let r=0;r<state.rounds.length;r++){
    for(let m=0;m<state.rounds[r].length;m++){
      const match = state.rounds[r][m];
      if(match && match.winner === player){
        clearWinner(r,m);
      }
    }
  }
  if(state.thirdMatch && state.thirdMatch.winner === player){
    state.thirdMatch.winner = null;
  }
}

function styleSideBtn(b, st){
  b.classList.remove("state--","state-済","state-未","state-欠","state-棄");
  b.classList.add("state-" + (st || "-"));
}

function createSideButton(player, parent){
  const b = document.createElement("button");
  b.className = "side-btn";
  b.type = "button";

  if(!player || isSeed(player)){
    b.textContent = "-";
    b.disabled = true;
    parent.appendChild(b);
    return;
  }

  if(player.attendance == null) player.attendance = "-";
  b.textContent = player.attendance;
  styleSideBtn(b, player.attendance);

  // 短押し(クリック)は無効：誤操作防止
  b.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
  });

  let pressTimer = null;

  const cycleState = () => {
    const cur = player.attendance || "-";
    const idx = ATT_STATES.indexOf(cur);
    const next = ATT_STATES[(idx + 1) % ATT_STATES.length];

    // 要件：棄にしても勝ち上がり/勝者履歴は消さない（表示だけ薄くする）
    player.attendance = next;
    b.textContent = next;
    styleSideBtn(b, next);

    render();
  };

  const startPress = () => {
    if(pressTimer) clearTimeout(pressTimer);
    pressTimer = setTimeout(() => {
      pressTimer = null;
      cycleState();
    }, LONG_PRESS_TIME);
  };

  const endPress = () => {
    if(pressTimer){
      clearTimeout(pressTimer);
      pressTimer = null;
    }
  };

  // PC
  b.addEventListener("mousedown", startPress);
  b.addEventListener("mouseup", endPress);
  b.addEventListener("mouseleave", endPress);

  // Mobile
  b.addEventListener("touchstart", startPress, { passive:true });
  b.addEventListener("touchend", endPress);
  b.addEventListener("touchcancel", endPress);

  parent.appendChild(b);
}


function renderBase(){
  const t = document.getElementById("tournament");
  const l = document.getElementById("lines");
  t.innerHTML = "";
  l.innerHTML = "";

  const TOP_PAD = getCssNum("--top-pad", 14);
  const BOX_H = getCssNum("--box-h", 88);

  const sideCol = document.createElement("div");
  sideCol.className = "side-column";

  const matchPad = getCssNum("--match-pad", 4);
  const playerMY = getCssNum("--player-my", 2);
  const btnH = getCssNum("--btn-h", 40);

  const firstBtnTopOffset = matchPad + playerMY;
  const secondBtnTopOffset = firstBtnTopOffset + btnH + (playerMY + playerMY);

  state.rounds[0].forEach((match, m) => {
    const wrapTop = calcY(0, m) + TOP_PAD;

    const r1 = document.createElement("div");
    r1.className = "side-row";
    r1.style.top = (wrapTop + firstBtnTopOffset) + "px";
    createSideButton(match.players[0], r1);
    sideCol.appendChild(r1);

    const r2 = document.createElement("div");
    r2.className = "side-row";
    r2.style.top = (wrapTop + secondBtnTopOffset) + "px";
    createSideButton(match.players[1], r2);
    sideCol.appendChild(r2);
  });

  t.appendChild(sideCol);

  state.rounds.forEach((round, r) => {
    const col = document.createElement("div");
    col.className = "column";

    round.forEach((_, m) => {
      const w = document.createElement("div");
      w.className = "match-wrapper";
      w.id = `r${r}m${m}`;
      w.style.top = (calcY(r, m) + TOP_PAD) + "px";

      const box = document.createElement("div");
      box.className = "match";
      w.appendChild(box);

      let pressTimer = null;
      const assignCourt = () => {
        if (selectedCourt && selectedCourt !== "-") {
          const match = state.rounds[r][m];
          match.court = selectedCourt;
          render();
        }
      };
      w.addEventListener("mousedown", (e)=>{
        if(e.target && e.target.tagName === "BUTTON") return;
        pressTimer = setTimeout(assignCourt, LONG_PRESS_TIME);
      });
      w.addEventListener("mouseup", ()=>clearTimeout(pressTimer));
      w.addEventListener("mouseleave", ()=>clearTimeout(pressTimer));
      w.addEventListener("touchstart", (e)=>{
        if(e.target && e.target.tagName === "BUTTON") return;
        pressTimer = setTimeout(assignCourt, LONG_PRESS_TIME);
      }, {passive:true});
      w.addEventListener("touchend", ()=>clearTimeout(pressTimer));

      col.appendChild(w);
    });

    t.appendChild(col);
  });

  const finalR = state.rounds.length - 1;
  const finalCol = t.children[t.children.length - 1];

  const thirdWrap = document.createElement("div");
  thirdWrap.className = "match-wrapper";
  thirdWrap.id = "thirdMatch";
  thirdWrap.style.top = (calcY(finalR, 0) + TOP_PAD + BOX_H + 34) + "px";

  const thirdBox = document.createElement("div");
  thirdBox.className = "match";
  thirdWrap.appendChild(thirdBox);

  let thirdPressTimer = null;
  const assignThirdCourt = () => {
    if (selectedCourt && selectedCourt !== "-") {
      state.thirdMatch.court = selectedCourt;
      render();
    }
  };
  thirdWrap.addEventListener("mousedown", (e)=>{
    if(e.target && e.target.tagName === "BUTTON") return;
    thirdPressTimer = setTimeout(assignThirdCourt, LONG_PRESS_TIME);
  });
  thirdWrap.addEventListener("mouseup", ()=>clearTimeout(thirdPressTimer));
  thirdWrap.addEventListener("mouseleave", ()=>clearTimeout(thirdPressTimer));
  thirdWrap.addEventListener("touchstart", (e)=>{
    if(e.target && e.target.tagName === "BUTTON") return;
    thirdPressTimer = setTimeout(assignThirdCourt, LONG_PRESS_TIME);
  }, {passive:true});
  thirdWrap.addEventListener("touchend", ()=>clearTimeout(thirdPressTimer));

  finalCol.appendChild(thirdWrap);

    // 縦スクロールの下限を「最下段match下端」で固定するためのスペーサ
  let spacer = document.getElementById("vSpacer");
  if(!spacer){
    spacer = document.createElement("div");
    spacer.id = "vSpacer";
    spacer.style.width = "1px";
    spacer.style.height = "1px";
  }
  t.appendChild(spacer);

}

function selectWinner(r, m, p, btn){
  if(!p) return;
  if(isSeed(p) || isAbsent(p) || isWithdraw(p)) return;

  if(pendingWin && pendingWin.r===r && pendingWin.m===m && pendingWin.p===p){
    clearSelection();
    win(r,m,p);
    return;
  }
  clearSelection();
  pendingWin = { r,m,p };
  btn.classList.add("selected");
}

function win(r,m,w){
  const match = state.rounds[r][m];
  if(match.winner) return;
  match.winner = w;

  const finalR = state.rounds.length - 1;
  if(r < finalR){
    const next = state.rounds[r+1][Math.floor(m/2)];
    const slot = m % 2;
    next.players[slot] = w;
    autoJudgeMatch(r+1, Math.floor(m/2));
  }

  if(r === finalR - 1){
    rebuildThirdMatch();
  }
  render();
}

function clearWinner(r,m){
  const match = state.rounds[r][m];
  if(!match || !match.winner) return;

  const finalR = state.rounds.length - 1;
  if(r < finalR){
    const next = state.rounds[r+1][Math.floor(m/2)];
    const slot = m % 2;
    if(next && next.players){
      if(next.winner) clearWinner(r+1, Math.floor(m/2));
      next.players[slot] = null;
    }
  }

  match.winner = null;

  if(r === finalR - 1 || r === finalR){
    rebuildThirdMatch();
    state.thirdMatch.winner = null;
  }

  render();
}

function rebuildThirdMatch(){
  const finalR = state.rounds.length - 1;
  const semiR = finalR - 1;
  const semi = state.rounds[semiR];

  if(!semi || semi.some(x=>!x.winner)){
    state.thirdMatch.players = [];
    state.thirdMatch.winner = null;
    return;
  }
  const losers = semi.map(m => m.players.find(p => p && p !== m.winner) || null);
  state.thirdMatch.players = losers;

  if(state.thirdMatch.winner && !losers.includes(state.thirdMatch.winner)){
    state.thirdMatch.winner = null;
  }
}

function selectThird(p, btn){
  if(!p) return;
  if(isSeed(p) || isAbsent(p) || isWithdraw(p)) return;

  if(pendingWin && pendingWin.r === -1 && pendingWin.m === -1 && pendingWin.p === p){
    clearSelection();
    state.thirdMatch.winner = p;
    render();
    return;
  }
  clearSelection();
  pendingWin = { r:-1, m:-1, p };
  btn.classList.add("selected");
}

function autoJudgeMatch(r,m){
  const match = state.rounds[r][m];
  if(!match || match.winner) return;

  const p1 = match.players[0];
  const p2 = match.players[1];
  const p1Seed = isSeed(p1);
  const p2Seed = isSeed(p2);

  if(p1Seed && !p2Seed && p2) { win(r,m,p2); return; }
  if(p2Seed && !p1Seed && p1) { win(r,m,p1); return; }
}

function render(){
  document.title = (document.getElementById("metaTitle").value || "トーナメント");

  state.rounds.forEach((round, r) => {
    round.forEach((match, m) => {
      const wrap = document.getElementById(`r${r}m${m}`);
      if(!wrap) return;
      const box = wrap.querySelector(".match");
      if(!box) return;

      box.innerHTML = "";
      box.style.border = "1px solid #111";
      if(match.court && match.court !== "-"){
        const idx = courtList.indexOf(match.court);
        if(idx >= 0){
          const c = courtColors[idx % courtColors.length];
          box.style.border = `4px solid ${c.border}`;
        }
      }

      match.players.forEach((p) => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "playerBtn";

        if(!p){
          b.textContent = "—";
          b.disabled = true;
          box.appendChild(b);
          return;
        }

        if(isDash(p)){
          b.textContent = "-";
          b.classList.add("seed");
          b.disabled = true;
          box.appendChild(b);
          return;
        }

        const [ln, fn] = splitName(p.name);
        b.innerHTML = `<span class="ln">${ln}</span><span class="fn">${fn}</span>`;

        if(isSeed(p)){ b.classList.add("seed"); b.disabled = true; }
        else if(isAbsent(p)){ b.classList.add("absent"); b.disabled = true; }
        else if(isWithdraw(p)){ b.classList.add("withdraw"); b.disabled = true; }

        if(match.winner){
          if(p === match.winner) b.classList.add("winner");
          else b.classList.add("loser");
        }

        b.addEventListener("click", () => {
          if(b._longPress){ b._longPress = false; return; }
          if(b.disabled) return;
          selectWinner(r,m,p,b);
        });

        let timer = null;
        b.onmousedown = b.ontouchstart = () => {
          if(match.winner !== p) return;
          timer = setTimeout(() => {
            b._longPress = true;
            clearWinner(r,m);
          }, LONG_PRESS_TIME);
        };
        b.onmouseup = b.onmouseleave = b.ontouchend = () => clearTimeout(timer);

        box.appendChild(b);
      });
    });
  });

  const thirdWrap = document.getElementById("thirdMatch");
  if(thirdWrap){
    const tbox = thirdWrap.querySelector(".match");
    tbox.innerHTML = "";

    const lab = document.createElement("div");
    lab.className = "matchLabel";
    lab.textContent = "3位決定戦";
    tbox.style.position = "relative";
    tbox.appendChild(lab);

    tbox.style.border = "1px solid #111";
    if(state.thirdMatch.court && state.thirdMatch.court !== "-"){
      const idx = courtList.indexOf(state.thirdMatch.court);
      if(idx >= 0){
        const c = courtColors[idx % courtColors.length];
        tbox.style.border = `4px solid ${c.border}`;
      }
    }

    const players = state.thirdMatch.players || [];
    for(let i=0;i<2;i++){
      const p = players[i] || null;
      const b = document.createElement("button");
      b.type = "button";
      b.className = "playerBtn";

      if(!p){
        b.textContent = "—";
        b.disabled = true;
        tbox.appendChild(b);
        continue;
      }

      if(isDash(p)){
        b.textContent = "-";
        b.classList.add("seed");
        b.disabled = true;
        tbox.appendChild(b);
        continue;
      }

      const [ln, fn] = splitName(p.name);
      b.innerHTML = `<span class="ln">${ln}</span><span class="fn">${fn}</span>`;

      if(isSeed(p)){ b.classList.add("seed"); b.disabled = true; }
      else if(isAbsent(p)){ b.classList.add("absent"); b.disabled = true; }
      else if(isWithdraw(p)){ b.classList.add("withdraw"); b.disabled = true; }

      if(state.thirdMatch.winner){
        if(p === state.thirdMatch.winner) b.classList.add("winner");
        else b.classList.add("loser");
      }

      b.addEventListener("click", () => {
        if(b._longPress){ b._longPress = false; return; }
        if(b.disabled) return;
        selectThird(p,b);
      });

      let timer = null;
      b.onmousedown = b.ontouchstart = () => {
        if(state.thirdMatch.winner !== p) return;
        timer = setTimeout(() => {
          b._longPress = true;
          state.thirdMatch.winner = null;
          render();
        }, LONG_PRESS_TIME);
      };
      b.onmouseup = b.onmouseleave = b.ontouchend = () => clearTimeout(timer);

      tbox.appendChild(b);
    }
  }

  drawRanks();
  requestAnimationFrame(drawLines);

    // 縦スクロールの下限（最下段match下端）を更新
  const tour = document.getElementById("tournament");
  const spacer = document.getElementById("vSpacer");
  if(tour && spacer){
    let maxBottom = 0;
    tour.querySelectorAll(".match-wrapper").forEach(el=>{
      const b = el.offsetTop + el.offsetHeight;
      if(b > maxBottom) maxBottom = b;
    });
    const bottomGap = getCssNum("--bottom-gap", 100);
    spacer.style.height = (maxBottom + bottomGap + 20) + "px";
  }

}

function drawLines(){
  const svg = document.getElementById("lines");
  const wrapper = document.getElementById("wrapper");
  const tour = document.getElementById("tournament");
  if(!svg || !wrapper || !tour) return;

  const wRect = wrapper.getBoundingClientRect();

  // --- コンテンツ実高さ（最下段matchの下端 + bottom-gap）を計算 ---
  let maxBottom = 0;
  tour.querySelectorAll(".match-wrapper").forEach(el=>{
    const b = el.offsetTop + el.offsetHeight;
    if(b > maxBottom) maxBottom = b;
  });
  const bottomGap = getCssNum("--bottom-gap", 100);
  const contentH = maxBottom + bottomGap + 20;

  // SVGがscrollTopで伸びて無限スクロールを発生させないように固定
  const width  = Math.max(wrapper.clientWidth, tour.scrollWidth, 300);
  const height = Math.max(wrapper.clientHeight, contentH, 300);

  svg.setAttribute("width", width);
  svg.setAttribute("height", height);
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svg.innerHTML = "";

  const addLine = (x1,y1,x2,y2,color,w)=>{
    const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
    ln.setAttribute("x1", x1); ln.setAttribute("y1", y1);
    ln.setAttribute("x2", x2); ln.setAttribute("y2", y2);
    ln.setAttribute("stroke", color);
    ln.setAttribute("stroke-width", w);
    ln.setAttribute("stroke-linecap","square");
    svg.appendChild(ln);
  };

  const center = (el)=>{
    const r = el.getBoundingClientRect();
    const x = (r.left - wRect.left) + wrapper.scrollLeft + (r.width/2);
    const y = (r.top  - wRect.top ) + wrapper.scrollTop  + (r.height/2);
    return {x,y};
  };

  for(let r=0; r<state.rounds.length-1; r++){
    const round = state.rounds[r];
    for(let m=0; m<round.length; m++){
      const wrap = document.getElementById(`r${r}m${m}`);
      const nextWrap = document.getElementById(`r${r+1}m${Math.floor(m/2)}`);
      if(!wrap || !nextWrap) continue;

      const btns = wrap.querySelectorAll(".match button.playerBtn");
      const nextBtns = nextWrap.querySelectorAll(".match button.playerBtn");
      if(btns.length < 2 || nextBtns.length < 2) continue;

      const dstBtn = nextBtns[m%2];
      const dst = center(dstBtn);

      const src0 = center(btns[0]);
      const src1 = center(btns[1]);

      const xMid = (src0.x + dst.x) / 2;

      addLine(src0.x, src0.y, xMid, src0.y, "#bdbdbd", 1.2);
      addLine(src1.x, src1.y, xMid, src1.y, "#bdbdbd", 1.2);
      addLine(xMid, src0.y, xMid, src1.y, "#bdbdbd", 1.2);
      addLine(xMid, (src0.y+src1.y)/2, xMid, dst.y, "#bdbdbd", 1.2);
      addLine(xMid, dst.y, dst.x, dst.y, "#bdbdbd", 1.2);

      const match = round[m];
      if(match && match.winner){
        const winIndex = (match.players[0]===match.winner) ? 0 : (match.players[1]===match.winner ? 1 : -1);
        if(winIndex === 0){
          addLine(src0.x, src0.y, xMid, src0.y, "red", 2);
          addLine(xMid, src0.y, xMid, dst.y, "red", 2);
          addLine(xMid, dst.y, dst.x, dst.y, "red", 2);
        }else if(winIndex === 1){
          addLine(src1.x, src1.y, xMid, src1.y, "red", 2);
          addLine(xMid, src1.y, xMid, dst.y, "red", 2);
          addLine(xMid, dst.y, dst.x, dst.y, "red", 2);
        }
      }
    }
  }
}


function drawRanks(){
  for(let i=1;i<=8;i++){
    const el = document.getElementById("rank"+i);
    if(el) el.textContent = i + "位：--";
  }

  const finalR = state.rounds.length - 1;
  if(finalR < 0) return;

  const finalMatch = state.rounds[finalR][0];
  if(!finalMatch || !finalMatch.winner) return;

  const winner = finalMatch.winner;
  const runner = finalMatch.players.find(p => p && p !== winner) || null;

  document.getElementById("rank1").textContent = "1位：" + (winner ? winner.name : "--");
  document.getElementById("rank2").textContent = "2位：" + (runner ? runner.name : "--");

  let third = null;
  let fourth = null;

  // 3rd-place match decided
  if(state.thirdMatch && state.thirdMatch.players && state.thirdMatch.players.length === 2 && state.thirdMatch.winner){
    third = state.thirdMatch.winner;
    fourth = state.thirdMatch.players.find(p => p && p !== third) || null;
  }else{
    // fallback: semi losers (when both semis decided)
    const semiR = finalR - 1;
    if(semiR >= 0){
      const semi = state.rounds[semiR];
      if(semi && semi.length === 2 && semi.every(m=>m.winner)){
        const losers = semi.map(m => m.players.find(p => p && p !== m.winner) || null);
        third = losers[0] || null;
        fourth = losers[1] || null;
      }
    }
  }

  document.getElementById("rank3").textContent = "3位：" + (third ? third.name : "--");
  document.getElementById("rank4").textContent = "4位：" + (fourth ? fourth.name : "--");

  // 5-8: quarterfinal losers, ordered by who they lost to (1st/2nd/3rd/4th)
  const semiR = finalR - 1;
  const quarterR = semiR - 1;
  if(quarterR >= 0){
    const q = state.rounds[quarterR];
    if(q && q.length === 4 && q.every(m=>m.winner)){
      const loserOf = (topPlayer) => {
        if(!topPlayer) return null;
        const m = q.find(mm => mm && mm.winner === topPlayer);
        if(!m) return null;
        return m.players.find(p => p && p !== topPlayer) || null;
      };

      const p5 = loserOf(winner);
      const p6 = loserOf(runner);
      const p7 = loserOf(third);
      const p8 = loserOf(fourth);

      document.getElementById("rank5").textContent = "5位：" + (p5 ? p5.name : "--");
      document.getElementById("rank6").textContent = "6位：" + (p6 ? p6.name : "--");
      document.getElementById("rank7").textContent = "7位：" + (p7 ? p7.name : "--");
      document.getElementById("rank8").textContent = "8位：" + (p8 ? p8.name : "--");
    }
  }
}

/* ===== ③ 保存（復元は起動時自動） ===== */
function serializeApp(){
  const meta = {
    title: document.getElementById("metaTitle").value || "",
    style: document.getElementById("metaStyle").value || "",
    type: document.getElementById("metaType").value || "",
    category: document.getElementById("metaCategory").value || "",
  };
  const ui = {
    courtCount: Number(document.getElementById("courtCountInput").value || 1),
    courtList: courtList.slice(),
    selectedCourt: selectedCourt || "-",
    playersText: document.getElementById("players").value || ""
  };

  const players = state.players.map(p => ({ id:p.id, name:p.name, attendance:p.attendance ?? "-" }));

  const encP = (p) => {
    if(!p) return null;
    if(isSeed(p)) return "seed";
    return p.id ?? null;
  };

  const rounds = state.rounds.map(round => round.map(m => ({
    players: [encP(m.players[0]), encP(m.players[1])],
    winner: encP(m.winner),
    court: m.court ?? null
  })));

  const third = {
    players: (state.thirdMatch.players || []).map(encP),
    winner: encP(state.thirdMatch.winner),
    court: state.thirdMatch.court ?? null
  };

  return { v:1, savedAt: Date.now(), meta, ui, players, rounds, third };
}

function restoreApp(data){
  if(!data || !data.v) return false;

  document.getElementById("metaTitle").value = data.meta?.title ?? "";
  document.getElementById("metaStyle").value = data.meta?.style ?? "";
  document.getElementById("metaType").value = data.meta?.type ?? "";
  document.getElementById("metaCategory").value = data.meta?.category ?? "";

  document.getElementById("courtCountInput").value = String(data.ui?.courtCount ?? 1);
  courtList = Array.isArray(data.ui?.courtList) ? data.ui.courtList.slice() : ["-"];
  selectedCourt = data.ui?.selectedCourt ?? "-";
  document.getElementById("players").value = data.ui?.playersText ?? "";

  const map = new Map();
  state.players = (data.players || []).map(p => {
    const obj = { id:p.id, name:p.name, attendance:p.attendance ?? "-" };
    map.set(obj.id, obj);
    return obj;
  });

  const decP = (x) => {
    if(x == null) return null;
    if(x === "seed") return makeSeed();
    return map.get(x) || null;
  };

  state.rounds = (data.rounds || []).map(round => (round || []).map(m => ({
    players: [decP(m.players?.[0]), decP(m.players?.[1])],
    winner: decP(m.winner),
    court: m.court ?? null
  })));

  state.thirdMatch = {
    players: (data.third?.players || []).map(decP),
    winner: decP(data.third?.winner),
    court: data.third?.court ?? null
  };

  pendingWin = null;

  buildCourtPalette(); // court inputs
  renderBase();
  render();
  return true;
}

function downloadJson(data){
  const title = (data.meta?.title || document.getElementById("metaTitle").value || "tournament")
    .replace(/[\/:*?"<>|]/g, "_");

  // ★ここで APP_KIND を使う（未定義でも落ちないようにする）
  const kind = (typeof APP_KIND !== "undefined" && APP_KIND) ? APP_KIND : "app";

  const dt = new Date();
  const y = dt.getFullYear();
  const m = String(dt.getMonth()+1).padStart(2,"0");
  const d = String(dt.getDate()).padStart(2,"0");
  const hh = String(dt.getHours()).padStart(2,"0");
  const mm = String(dt.getMinutes()).padStart(2,"0");

  // ★kind をファイル名に入れる
  const fileName = `${title}_${kind}_${y}${m}${d}_${hh}${mm}.json`;

  const blob = new Blob([JSON.stringify(data, null, 2)], { type:"application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}


function tempSave(){
  const data = serializeApp();
  try{ localStorage.setItem(TEMP_KEY, JSON.stringify(data)); }catch(_){ }
  downloadJson(data);
}

function finalSave(){
  const data = serializeApp();
  downloadJson(data);
}

document.getElementById("tempSaveBtn").addEventListener("click", tempSave);
document.getElementById("finalSaveBtn").addEventListener("click", finalSave);

// JSON読込
(function(){
  const btn = document.getElementById("loadBtn");
  const inp = document.getElementById("loadFile");
  if(btn && inp){
    btn.addEventListener("click", ()=>inp.click());
    inp.addEventListener("change", async () => {
      const f = inp.files && inp.files[0];
      if(!f) return;
      try{
        const txt = await f.text();
        const data = JSON.parse(txt);
        restoreApp(data);
        try{ localStorage.setItem(TEMP_KEY, JSON.stringify(data)); }catch(_){ }
      }catch(e){
        alert("読込に失敗しました");
      }finally{
        inp.value = "";
      }
    });
  }
})();

function startTournament(){
  const raw = document.getElementById("players").value
    .split(/\r?\n/)
    .map(v => v.trim())
    .filter(Boolean);

  if(raw.length < 2){
    alert("2名以上必要です");
    return;
  }

  let idSeq = 1;
  state.players = raw.map(v => ({ id: idSeq++, name:v, attendance:"-" }));
  pendingWin = null;

  buildRoundsFull();
  renderBase();
  render();
}

document.getElementById("startBtn").addEventListener("click", startTournament);
document.getElementById("wrapper").addEventListener("scroll", ()=>requestAnimationFrame(drawLines));
window.addEventListener("resize", ()=>requestAnimationFrame(drawLines));

applyCourtCount();
buildCourtPalette();

/* 起動時：一時保存があれば自動復元 */
(() => {
  try{
    const s = localStorage.getItem(TEMP_KEY);
    if(!s) return;
    const data = JSON.parse(s);
    restoreApp(data);
  }catch(_){}
})();


/* ===== Vercel同期（カテゴリ別JSON） ===== */
const SAVE_TOKEN_KEY = "KARATE_SAVE_TOKEN";
const LAST_CAT_KEY = "KARATE_LAST_CAT_" + (typeof APP_KIND !== "undefined" ? APP_KIND : "app");
const CATEGORY_LIST = [{"cat": "team_e34_m", "label": "団体戦 小学３・４年男子の部", "style": "団体戦"}, {"cat": "team_e34_f", "label": "団体戦 小学３・４年女子の部", "style": "団体戦"}, {"cat": "team_e56_m", "label": "団体戦 小学５・６年男子の部", "style": "団体戦"}, {"cat": "team_e56_f", "label": "団体戦 小学５・６年女子の部", "style": "団体戦"}, {"cat": "team_jhs_m", "label": "団体戦 中学生男子の部", "style": "団体戦"}, {"cat": "team_jhs_f", "label": "団体戦 中学生女子の部", "style": "団体戦"}, {"cat": "team_hs_m", "label": "団体戦 高校生男子の部", "style": "団体戦"}, {"cat": "team_hs_f", "label": "団体戦 高校生女子の部", "style": "団体戦"}, {"cat": "team_adult_m", "label": "団体戦 一般男子の部", "style": "団体戦"}, {"cat": "team_adult_f", "label": "団体戦 一般女子の部", "style": "団体戦"}, {"cat": "ind_e3_m", "label": "個人戦 小学３年男子の部", "style": "個人戦"}, {"cat": "ind_e3_f", "label": "個人戦 小学３年女子の部", "style": "個人戦"}, {"cat": "ind_e4_m", "label": "個人戦 小学４年男子の部", "style": "個人戦"}, {"cat": "ind_e4_f", "label": "個人戦 小学４年女子の部", "style": "個人戦"}, {"cat": "ind_e5_m", "label": "個人戦 小学５年男子の部", "style": "個人戦"}, {"cat": "ind_e5_f", "label": "個人戦 小学５年女子の部", "style": "個人戦"}, {"cat": "ind_e6_m", "label": "個人戦 小学６年男子の部", "style": "個人戦"}, {"cat": "ind_e6_f", "label": "個人戦 小学６年女子の部", "style": "個人戦"}, {"cat": "ind_j1_m", "label": "個人戦 中学１年男子の部", "style": "個人戦"}, {"cat": "ind_j1_f", "label": "個人戦 中学１年女子の部", "style": "個人戦"}, {"cat": "ind_j2_m", "label": "個人戦 中学２年男子の部", "style": "個人戦"}, {"cat": "ind_j2_f", "label": "個人戦 中学２年女子の部", "style": "個人戦"}, {"cat": "ind_j3_m", "label": "個人戦 中学３年男子の部", "style": "個人戦"}, {"cat": "ind_j3_f", "label": "個人戦 中学３年女子の部", "style": "個人戦"}, {"cat": "ind_hs_m", "label": "個人戦 高校生男子の部", "style": "個人戦"}, {"cat": "ind_hs_f", "label": "個人戦 高校生女子の部", "style": "個人戦"}, {"cat": "ind_adult_m", "label": "個人戦 一般男子の部", "style": "個人戦"}, {"cat": "ind_adult_f", "label": "個人戦 一般女子の部", "style": "個人戦"}];

function qsParam(name){
  try{ return new URLSearchParams(location.search).get(name); }catch(_){ return null; }
}

function getKind(){
  return (typeof APP_KIND !== "undefined" && APP_KIND) ? APP_KIND : "kumite";
}

function buildCatSelect(){
  const sel = document.getElementById("catSelect");
  if(!sel) return;
  sel.innerHTML = "";
  CATEGORY_LIST.forEach(it=>{
    const opt=document.createElement("option");
    opt.value=it.cat;
    opt.textContent=it.label;
    sel.appendChild(opt);
  });

  const param = qsParam("cat");
  const saved = (()=>{ try{return localStorage.getItem(LAST_CAT_KEY);}catch(_){return null;} })();
  const initial = param || saved || (CATEGORY_LIST[0]?.cat || "");
  sel.value = initial;

  sel.addEventListener("change", ()=>{
    try{ localStorage.setItem(LAST_CAT_KEY, sel.value); }catch(_){ }
    const it = CATEGORY_LIST.find(x=>x.cat===sel.value);
    if(it){
      try{ document.getElementById("metaStyle").value = it.style || ""; }catch(_){ }
      try{ document.getElementById("metaCategory").value = it.label.replace(/^団体戦\s+|^個人戦\s+/, ""); }catch(_){ }
    }
  });

  // 1回反映
  sel.dispatchEvent(new Event("change"));
}

function getCurrentCat(){
  const sel=document.getElementById("catSelect");
  return (sel && sel.value) ? sel.value : (qsParam("cat") || "");
}

function setLastSyncText(msg){
  const el=document.getElementById("lastSync");
  if(el) el.textContent = msg || "";
}

function nowHHMMSS(){
  const d=new Date();
  const hh=String(d.getHours()).padStart(2,"0");
  const mm=String(d.getMinutes()).padStart(2,"0");
  const ss=String(d.getSeconds()).padStart(2,"0");
  return `${hh}:${mm}:${ss}`;
}

async function serverLoad(){
  const cat=getCurrentCat();
  if(!cat){ alert("カテゴリが未選択です"); return; }
  const kind=getKind();
  setLastSyncText("読込中…");
  try{
    const res = await fetch(`/api/load?kind=${encodeURIComponent(kind)}&cat=${encodeURIComponent(cat)}`, { cache:"no-store" });
    if(res.status===404){
      setLastSyncText(`未保存（${nowHHMMSS()}）`);
      return;
    }
    if(!res.ok){
      setLastSyncText(`読込失敗（${res.status}）`);
      return;
    }
    const data = await res.json();
    restoreApp(data);
    setLastSyncText(`読込 OK（${nowHHMMSS()}）`);
  }catch(e){
    setLastSyncText(`読込失敗（${nowHHMMSS()}）`);
  }
}

function getSaveToken(){
  let t="";
  try{ t = localStorage.getItem(SAVE_TOKEN_KEY) || ""; }catch(_){ }
  if(!t){
    t = prompt("サーバー保存キー（初回のみ）\n※Vercelの環境変数 SAVE_TOKEN と一致させてください");
    if(!t) return "";
    try{ localStorage.setItem(SAVE_TOKEN_KEY, t); }catch(_){ }
  }
  return t;
}

async function serverSave(){
  const cat=getCurrentCat();
  if(!cat){ alert("カテゴリが未選択です"); return; }
  const kind=getKind();
  const token=getSaveToken();
  if(!token) return;

  const who = (document.getElementById("whoInput")?.value || "").trim();
  const payload = serializeApp();
  // UI情報を追記（あっても無視されてもOK）
  payload.ui = payload.ui || {};
  payload.ui.updatedAt = new Date().toISOString();
  if(who) payload.ui.updatedBy = who;

  setLastSyncText("保存中…");
  try{
    const res = await fetch(`/api/save?kind=${encodeURIComponent(kind)}&cat=${encodeURIComponent(cat)}`, {
      method:"POST",
      headers:{"content-type":"application/json","x-save-token": token},
      body: JSON.stringify(payload)
    });
    if(!res.ok){
      setLastSyncText(`保存失敗（${res.status}）`);
      alert("サーバー保存に失敗しました（保存キーやVercel設定を確認）");
      return;
    }
    setLastSyncText(`保存 OK（${nowHHMMSS()}）`);
  }catch(e){
    setLastSyncText(`保存失敗（${nowHHMMSS()}）`);
    alert("サーバー保存に失敗しました");
  }
}

function setViewerMode(enable){
  const vRow = document.getElementById("viewerRow");
  const sRow = document.getElementById("syncRow");
  if(vRow) vRow.style.display = enable ? "flex" : "none";
  if(sRow) sRow.style.display = enable ? "none" : "flex";

  const disableIds = ["startBtn","saveBtn","tempSaveBtn","finalSaveBtn","players","courtCountInput","setCourtCountBtn","metaTitle","metaStyle","metaType","metaCategory"]; 
  disableIds.forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    if(el.tagName==="TEXTAREA" || el.tagName==="INPUT") el.readOnly = enable;
    if(el.tagName==="BUTTON") el.disabled = enable;
  });

  // トーナメント内の操作を無効化（描画は維持）
  const wrapper=document.getElementById("wrapper");
  if(wrapper){
    wrapper.querySelectorAll("button").forEach(b=>{
      // viewer用ボタンは除外
      if(b.id==="refreshBtn") return;
      b.disabled = enable;
    });
  }
}

let _autoTimer=null;
function setupViewerAutoRefresh(){
  const tgl=document.getElementById("autoRefreshToggle");
  const sec=document.getElementById("autoRefreshSec");
  const refresh=document.getElementById("refreshBtn");

  if(refresh) refresh.addEventListener("click", serverLoad);

  function clear(){ if(_autoTimer){ clearInterval(_autoTimer); _autoTimer=null; } }
  function start(){
    clear();
    const s = Math.max(10, Math.min(600, Number(sec?.value || 90)));
    _autoTimer=setInterval(serverLoad, s*1000);
  }

  if(tgl){
    tgl.addEventListener("change", ()=>{ tgl.checked ? start() : clear(); });
  }
  if(sec){
    sec.addEventListener("change", ()=>{ if(tgl && tgl.checked) start(); });
  }
}

(function initVercelSync(){
  buildCatSelect();

  const loadBtn=document.getElementById("srvLoadBtn");
  const saveBtn=document.getElementById("srvSaveBtn");
  if(loadBtn) loadBtn.addEventListener("click", serverLoad);
  if(saveBtn) saveBtn.addEventListener("click", serverSave);

  const mode = (qsParam("mode") || "editor").toLowerCase();
  const isViewer = (mode === "viewer");
  setViewerMode(isViewer);
  setupViewerAutoRefresh();

  // viewerモード or autoload=1 のときは最初に読込
  const autoload = (qsParam("autoload") === "1") || isViewer;
  if(autoload){
    setTimeout(serverLoad, 150);
  }
})();

</script>
</body>
</html>
